import os
from subprocess import check_call, Popen, PIPE
import sys
from unittest import TestCase

# Constants:
TEST_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..")
PROJ_DIR = os.path.join(TEST_DIR, "..")
EXTRA_DIRS = [os.path.join(TEST_DIR, "stubs")]


class TestStaticAnalysis(TestCase):
    def test_code_is_blackened(self):
        os.chdir(PROJ_DIR)
        # NB: This is a workaround for the (autogenerated) _version.py not matching black's formatting.
        # check_call([sys.executable, "-m", "black", "src/snapstack/_version.py"])
        for path in [
            os.path.join(PROJ_DIR, "style_stripper"),
            os.path.join(PROJ_DIR, "test", "tests"),
        ]:
            check_call([sys.executable, "-m", "black", "--check", path])

    def test_mypy(self):
        """Should pass mypy"""
        # Run mypy over source
        os.chdir(PROJ_DIR)
        os.environ["MYPYPATH"] = os.pathsep.join(EXTRA_DIRS)
        process = Popen(["mypy", "style_stripper"], stdout=PIPE)
        stdout = process.stdout.read()
        process.wait()
        warnings = [
            line
            for line in stdout.decode("utf-8").split("\n")
            if line.startswith("portal" + os.path.sep)
        ]
        print("\nError: %d mypy warnings found" % len(warnings))
        for error in warnings:
            print(error.strip())
        assert not warnings

    def test_safety(self):
        """Should have no vulnerabilities"""
        # Run safety over source
        os.chdir(os.path.join(PROJ_DIR, "style_stripper"))
        check_call(["safety", "check"])
